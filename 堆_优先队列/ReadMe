堆的应用
堆排序
Top K问题   
求前k大的元素，则维护一个大小为K的小根堆，利用小根堆堆顶元素为堆最小值的性质，遍历数组：
如果堆不满，则直接插入；如果堆已满，则比较堆顶元素与当前元素，大于堆顶元素则删除堆顶元素同时将此元素插入；
直到遍历整个数组后，堆中的全部元素即为前k大的元素。                            （时间复杂度 O(Nlogk))

全部元素堆排序，依次pop  （时间复杂度O(N+klogN) 
















215
维护动态数据的最大最小值，可以考虑堆
在 Java 中，通过比较器确定元素是从小到大排列还是从大到小取决于比较器的实现方式。
在给定的Lambda表达式 (n1, n2) -> n1 - n2 中，返回的是 n1 - n2，这意味着如果 n1 小于 n2，则返回负数，如果 n1 大于 n2，则返回正数，如果它们相等，则返回0。
因此，这个比较器的行为是：
如果 n1 小于 n2，则 n1 会被排在 n2 前面，因此队列会从小到大排列。
如果 n1 大于 n2，则 n1 会被排在 n2 后面，因此队列会从大到小排列。
换句话说，通过这个比较器，优先队列会按照元素的大小从小到大进行排序。如果想要从大到小排序，则应该使用 (n1, n2) -> n2 - n1 作为比较器。
即 (n1, n2) -> n1 - n2 从小到大排列
   (n1, n2) -> n2 - n1 从大到小排列

2542
有约束，多维求最佳常用的一种方式。其中 A 可以是 除法/加法等，B 为单个元素（最大/最小值）
让 B 保持和题目最佳渐远的方式变化，比如题目要最大值，那么就降序
每次移除 A 中的最差结果，换一个更好的结果，也就是在 B 变差的情况下，A需要变好，才能让答案更优
比较获得最优解
Arrays.sort 方法接受的比较器参数需要的是 Comparator 接口，它要求元素的类型必须是引用类型而不是基本数据类型
